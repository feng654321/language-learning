# static
在C++中，static 关键字是一个多功能的修饰符，其含义和作用会根据其所修饰的实体（变量、函数、类成员）和上下文（局部、全局、类内）而有所不同。但其核心思想始终围绕着两个主要方面：`存储期`和`链接性`。
## 1.1、存储期：生命周期与内存位置  
存储期决定了变量的生命周期以及它在内存中的位置。C++中有四种存储期：
- 自动存储期 ：这是局部变量的默认存储期。它们在进入其作用域时创建，在离开作用域时销毁，通常存储在栈上。
- 静态存储期：被 static 修饰的局部变量、全局变量和静态类成员变量都具有静态存储期。它们在程序启动时创建，在程序结束时销毁。这些变量通常存储在程序的静态存储区，包括数据段（已初始化）和BSS段（未初始化）。
- 线程存储期：使用 `thread_local` 关键字修饰的变量具有线程存储期。它们在线程开始时创建，在线程结束时销毁，每个线程拥有自己独立的副本。
- 动态存储期：通过 `new` 或 `malloc` 动态分配的内存具有动态存储期。它们在程序运行时创建，需要通过 delete 或 free 手动销毁，存储在堆上。

## 1.2 链接性：可见范围
链接性决定了名称（变量名、函数名）在不同编译单元（.cpp文件）之间的可见性。C++中有三种链接性：
- 外部链接 (External Linkage)：默认情况下，全局变量和非 static 函数具有外部链接。这意味着它们可以在程序的任何编译单元中被访问和使用。
- 内部链接 (Internal Linkage)：当 static 修饰全局变量或函数时，它改变了这些实体的链接性，使其从外部链接变为内部链接。这意味着它们只在定义它们的编译单元内部可见和使用，不会与其他编译单元中的同名实体发生冲突。
- 无链接 (No Linkage)：局部变量（非 static）没有链接性，它们只在定义它们的作用域内可见。

### static 修饰全局变量
当 static 修饰全局变量时，该变量的链接性变为内部链接。这可以有效避免命名冲突，并限制变量的作用范围。
### static 修饰函数
当 static 修饰函数时，该函数的链接性变为内部链接。这通常用于工具函数或辅助函数，确保它们不会被其他编译单元意外调用，从而提高代码的模块化和安全性。

## static 在类中的应用
### 静态成员变量
- 共享性：静态成员变量属于类本身，而不是类的任何特定对象。这意味着类的所有对象共享同一个静态成员变量的副本。它在内存中只有一份，不随对象的创建而多次分配。
- 存储期：具有静态存储期，在程序启动时分配内存并初始化，在程序结束时销毁。
- 初始化：静态成员变量必须在类外部进行定义和初始化（常量静态整型成员可以在类内初始化）。  
注意：<span style="color:red"> `如果是 constexpr static 或 inline static（C++17 起），可以直接在类里初始化，不必在类外再写一遍。`</span>

### 静态成员函数
- 独立于对象：静态成员函数不与任何特定的对象关联。它们可以直接通过类名调用，无需创建类的对象。
- 无 this 指针：由于不与对象关联，静态成员函数没有 this 指针，因此不能直接访问类的非静态成员变量和非静态成员函数。
- 访问限制：静态成员函数只能访问类的静态成员变量、静态成员函数以及类外部的全局变量和函数。

# 静态全局变量啥时候初始化
## 静态全局变量的初始化时机
"静态全局变量"通常指的是在文件作用域（即任何函数之外）使用 static 关键字声明的变量。这类变量具有静态存储期（Static Storage Duration）和内部链接性（Internal Linkage）。它们的初始化时机遵循C++的静态存储期变量初始化规则。C++中具有静态存储期的变量（包括静态全局变量、普通全局变量、静态局部变量、静态类成员变量）的初始化分为两个阶段：
1. 静态初始化（Static Initialization）：零初始化（Zero-initialization）：在所有其他初始化发生之前，所有具有静态存储期的变量都会被零初始化。这意味着它们的内存会被填充为二进制零。对于整型变量，这意味着它们被初始化为0；对于浮点型变量，它们被初始化为0.0；对于指针类型，它们被初始化为nullptr；对于聚合类型（如数组、结构体），它们的成员会被递归地零初始化。常量初始化（Constant Initialization）：如果变量可以用常量表达式初始化，那么它会在零初始化之后，但在任何动态初始化之前进行初始化。这包括用字面量、constexpr变量或const表达式初始化的变量。
2. 动态初始化（Dynamic Initialization）：如果变量不能进行常量初始化（例如，使用非const变量或函数调用的结果进行初始化），那么它会在程序执行到其定义点时进行动态初始化。对于静态全局变量，这意味着在main函数执行之前，或者在首次使用该变量之前（C++11及以后标准保证局部静态变量的延迟初始化），会执行其初始化表达式。  

总结来说，静态全局变量的初始化时机是：
- 在程序启动时：在main函数执行之前，所有静态存储期变量的内存就已经分配好。
- 先零初始化：所有静态存储期变量的内存首先被填充为二进制零。
- 再常量初始化（如果适用）：如果变量可以用常量表达式初始化，则在零初始化之后进行。
- 最后动态初始化（如果适用）：如果变量需要动态初始化，则在程序执行到其定义点时进行。

# 类里面为啥要有 static 函数
static 成员函数存在的根本原因在于，有时我们需要执行与某个类逻辑相关，但又不需要访问该类任何特定对象状态的操作。非静态成员函数总是隐式地接收一个 this 指针，指向调用该函数的对象实例，因此它们可以访问对象的非静态成员变量和函数。然而，当一个操作不需要知道是哪个具体对象在执行它时，this 指针就显得多余，甚至可能导致设计上的不合理。  
static 成员函数解决了这个问题：
- 独立于对象：它们不依赖于类的任何对象实例。这意味着你可以在没有创建任何类对象的情况下调用静态成员函数。
- 没有 this 指针：由于不与特定对象绑定，静态成员函数内部没有 this 指针。这直接导致它们不能直接访问类的非静态成员变量和非静态成员函数，因为这些成员需要 this 指针来定位。
- 只能访问静态成员：静态成员函数只能直接访问类的静态成员变量和静态成员函数，以及类外部的全局变量和函数。这是因为静态成员本身也独立于对象，存在于程序的静态存储区。

## static 函数的用途和应用场景
1. 工具函数或辅助函数
当一个函数的功能是为类提供某种服务，但该服务不依赖于任何特定的对象状态时，将其设计为静态成员函数是最佳选择。例如，数学计算类、字符串处理类中的一些通用方法。
2. 工厂方法
工厂方法是一种创建对象的设计模式。当对象的创建过程比较复杂，或者需要根据某些参数创建不同类型的对象时，可以使用静态成员函数作为工厂方法。这样，用户无需了解具体的构造函数细节，只需调用静态方法即可。
3. 单例模式
单例模式确保一个类只有一个实例，并提供一个全局访问点。实现单例模式最常见的方式就是使用静态成员函数来获取类的唯一实例。
4. 访问和管理静态成员变量
静态成员函数是访问和管理静态成员变量的自然方式。由于静态成员变量属于类本身，静态成员函数可以方便地对其进行操作，而无需创建对象。
